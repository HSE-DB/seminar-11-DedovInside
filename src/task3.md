# Задание 3

**1.** Создайте таблицу с большим количеством данных:

```sql
CREATE TABLE test_cluster AS 
SELECT 
    generate_series(1,1000000) as id,
    CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
    md5(random()::text) as data;
```

```md
[2025-12-18 14:45:59] workshop.public> CREATE TABLE test_cluster AS
                                       SELECT
                                           generate_series(1,1000000) as id,
                                           CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
                                           md5(random()::text) as data
[2025-12-18 14:46:00] 1,000,000 rows affected in 1 s 154 ms
```

**2.** Создайте индекс:

```sql
CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
```

```md
[2025-12-18 14:46:23] workshop.public> CREATE INDEX test_cluster_cat_idx ON test_cluster(category)
[2025-12-18 14:46:23] completed in 296 ms
```

**3.** Измерьте производительность до кластеризации:

```sql
EXPLAIN ANALYZE
SELECT * FROM test_cluster WHERE category = 'A';
```

*План выполнения:*
Bitmap Heap Scan on test_cluster  (cost=5575.17..20208.76 rows=499967 width=39) (actual time=9.705..69.163 rows=500255 loops=1)
  Recheck Cond: (category = 'A'::text)
  Heap Blocks: exact=8334
  ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..5450.18 rows=499967 width=0) (actual time=8.879..8.880 rows=500255 loops=1)
        Index Cond: (category = 'A'::text)
Planning Time: 0.258 ms
Execution Time: 79.211 ms

*Объясните результат:*

```md
План показывает, что для выборки большого объёма данных (~50% таблицы) PostgreSQL использовал эффективную стратегию Bitmap-сканирования, но из-за случайного распределения данных потребовалось прочитать много блоков.

Выбор стратегии - оптимизатор выбрал Bitmap Heap Scan, так как нужно выбрать 500,255 строк (почти половину таблицы). Для такого большого процента данных прямое сканирование индекса (Index Scan) было бы неэффективно.

Два этапа выполнения:

- Bitmap Index Scan - индекс test_cluster_cat_idx быстро построил битовую карту всех строк с category = 'A'
- Bitmap Heap Scan - система загрузила 8334 блока данных (Heap Blocks: exact=8334) и перепроверила каждую строку (Recheck Cond)

Причина времени выполнения (79 мс) - данные распределены случайно (генерация через random()), поэтому строки с category = 'A' разбросаны по всей таблице. Пришлось прочитать и проверить много блоков.

Селективность индекса - индекс не очень полезен при выборке 50% данных, но Bitmap-сканирование всё равно эффективнее полного сканирования таблицы.

Такой план оптимален для некластеризованных данных. Кластеризация таблицы по category могла бы значительно ускорить этот запрос, разместив все строки категории 'A' в соседних блоках и уменьшив количество читаемых блоков.
```

**4.** Выполните кластеризацию:

```sql
CLUSTER test_cluster USING test_cluster_cat_idx;
```

*Результат:*

```md
[2025-12-18 14:51:46] workshop.public> CLUSTER test_cluster USING test_cluster_cat_idx
[2025-12-18 14:51:46] completed in 480 ms
```

**5.** Измерьте производительность после кластеризации:

```sql
EXPLAIN ANALYZE
SELECT * FROM test_cluster WHERE category = 'A';
```

*План выполнения:*

```md
Bitmap Heap Scan on test_cluster  (cost=5575.17..20158.76 rows=499967 width=39) (actual time=7.984..38.377 rows=500255 loops=1)
  Recheck Cond: (category = 'A'::text)
  Heap Blocks: exact=4169
  ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..5450.18 rows=499967 width=0) (actual time=7.613..7.614 rows=500255 loops=1)
        Index Cond: (category = 'A'::text)
Planning Time: 0.174 ms
Execution Time: 47.991 ms
```

*Объясните результат:*

```md
План показывает, что кластеризация по индексу category значительно ускорила запрос - время выполнения сократилось с 79 мс до 48 мс (ускорение в 1.6 раза).

1. Главное улучшение - количество читаемых блоков уменьшилось вдвое: с 8334 до 4169 (Heap Blocks: exact=4169). После кластеризации все строки с category = 'A' физически расположены в соседних блоках на диске, а не разбросаны случайно.

2. Стратегия выполнения не изменилась - PostgreSQL по-прежнему использует Bitmap Heap Scan, так как выбирается 50% данных (500,255 строк). Оптимизатор правильно определил, что для такого объёма данных прямое сканирование индекса было бы неэффективно.

3. Почему ускорилось время выполнения:

- До кластеризации: строки 'A' были равномерно разбросаны по всей таблице → приходилось читать почти все блоки
- После кластеризации: строки 'A' сгруппированы в первых ~50% блоков → читается только половина таблицы

4. Точность оценки - планировщик точно оценил количество строк (rows=499967 vs фактические 500255), что помогло выбрать оптимальный план.
```

**6.** Сравните производительность до и после кластеризации:

*Сравнение:*

```md
Фактически всё было описано в пункте выше, но вот ключевыt выводы:

- Основной выигрыш - кластеризация сократила количество блоков для чтения вдвое, так как все строки с category = 'A' теперь физически расположены в соседних блоках диска.
- Эффект для больших выборок - для запросов, выбирающих значительную часть таблицы (50% в данном случае), кластеризация даёт максимальный эффект за счёт последовательного чтения смежных блоков вместо случайных обращений.
- Тип плана остался прежним (Bitmap Heap Scan) - оптимальный для выборки 500K строк
- Оценка оптимизатора осталась точной (~500K строк)

**Вывод**: Кластеризация наиболее эффективна для запросов, которые выбирают большие диапазоны данных по индексируемому полю. В этом случае она уменьшает количество случайных чтений с диска за счёт физического упорядочивания строк.
```
